library(shiny)
library(markdown)
library(shinydashboard)
library(DynTxRegime)
library(DT)
library(rgenoud)

# server.R
# Limit Upload Data Size to 5Mb
options(shiny.maxRequestSize=5*1024^2)
shinyServer(
	function(input, output, session) {

	  ##------------------------ Load html files of case studies for methods --------------------------#
	  
	  #-----------------------
	  # Include html files 
	  #   include the html files generated by knitting
	  #   the corresponding markdown files in ./www folder
	  #     Dataset 
	  #     Outcome Regression : Case Study
	  #     AIPWE : Case Study
	  #     Classification: Case Study
	  #   and output as uioutput in ui.R
	  #   this step is necssary for those files, 
	  #   as they include some code chuncks need to be run beforehand
	  #-----------------------
	  output$dataone <- renderUI({
	    withMathJax(
	      includeHTML("./www/one_stage_dat.html"))
	    })
	  output$orc <- renderUI({
	    withMathJax(
	      includeHTML("./www/outcome_regress_case.html"))
	    })
	 	output$ac <- renderUI({
	 	  withMathJax(
	    includeHTML("./www/aipwe_case.html"))
	 	  })
	  output$cc <- renderUI({
	    withMathJax(
	    includeHTML("./www/class_case.html"))
	    })


	  ##----------------- Load csv file: input data  --------------------------#
	  
	  #-----------------------
	  # Read uploaded csv file
	  #   allow user to update their own small dataset,
	  #   limit upload data size to 5Mb
	  #-----------------------
	  data <- callModule(csvFile, "datafile",
	          stringsAsFactors = FALSE)
	  
	  ##------------------------ User data upload  --------------------------#
	  
	  #-----------------
	  # Datatable Output
	  #   generate renderDataTable for the dataset uploaded by the user
	  #-----------------
	  output$table <- renderDataTable({
	    data()
	  })
	  
	  #-----------------------------
	  # Scatter plots with Go button
	  #   let user generate a scatter plot for the data uploaded
	  #-----------------------------
	  observeEvent(input$getplot, {
	    output$plot0 <- renderPlot({
	      if (is.null(data())) return(NULL)
	      df <-data()
	      pairs(df)
	    })
	  })
	  
	  ########################################################################
	  ##--------------------------- Hands-on for Methods --------------------#
	  ########################################################################
	  
	  ##--------------------- outcome regression ----------------------#
	  #---------------------
	  # Specify treatment
	  #   create a box for drop list for user to select the treatment variable
	  #---------------------
	  output$varTrtR <- renderUI({
	    if (is.null(data())) return(NULL)
	    df <-data()
	    
	    items=names(df)
	    names(items)=items
	    selectInput("varTrtR", "Treatment:",items)
	  })
	  
	  #-----------------
	  # Specify response
	  #   create a box for drop list for user to select the response variable
	  #-----------------
	  output$varResponseR <- renderUI({
	    if (is.null(data())) return(NULL)
	    df <-data()
	    
	    items=names(df)
	    names(items)=items
	    selectInput("varResponseR", "Response:",items)
	  })
	  
	  #-------------
	  # Specify moMain
	  #   create a list of checkbox for multi-seleciton, allow the user to select
	  #   variables to be included in the moMain modeling
	  #-------------
	  output$varMainR <- renderUI({
	    if (is.null(data())) return(NULL)
	    df <-data()
	    
	    varName <- names(df)
	    varName <- varName[!(varName %in% c(input$varTrtR, input$varResponseR)) ]
	    checkboxGroupInput("varMainR", 
	                       "Choose variables to be included in the main effect model", 
	                       varName)
	  })
	  
	  #-------------
	  # Specify moCont
	  #   create a list of checkbox for multi-seleciton, allow the user to select
	  #   variables to be included in the moCont modeling
	  #-------------
	  output$varContR <- renderUI({
	    if (is.null(data())) return(NULL)
	    df <-data()
	    
	    varName <- names(df)
	    varName <- varName[!(varName %in% c(input$varTrtR, input$varResponseR)) ]
	    checkboxGroupInput("varContR", 
	                       "Choose variables to be included in the contrast model", 
	                       varName)
	  })
	  
	  #-------------
	  # Fit the model 
	  #   fit the model specified by user
	  #-------------  
	  observeEvent(input$getmodelR, {
	  # observe({
	    # check if data if uploaded
	    if (is.null(data())) return(NULL)
	    df <-data()
	    
	    # check if all the variables input are ready  
	    if(is.null(input$varResponseR)) return(NULL)
	    if(is.null(input$varTrtR)) return(NULL)
	    
	    if (is.null(input$varMainR)) return(NULL)
	    if (is.null(input$varContR)) return(NULL)
	    
	    # fit model when user request
	    # user active the model fit
	    # by hit the GO button 
	    if (input$getmodelR == 0) return(NULL)
	    
	    # build moMain and moCont
	    # put the selected variables into buildModelObj funcntion
	    varMainVectorR <- as.vector(input$varMainR)
	    varContVectorR <- as.vector(input$varContR)
	    myMainR <- paste("~", paste(varMainVectorR, collapse=" + "))
	    myContR <- paste("~", paste(varContVectorR, collapse=" + "))
	    output$myMainR <- renderText({paste("moMain <- buildModelObj(model =",  
	                                        myMainR, ",  solver.method='lm')")})
	    output$myContR <- renderText({paste("moCont <- buildModelObj(model =",  
	                                        myContR, ",  solver.method='lm')")})
	    moMainR <- buildModelObj(model = as.formula(myMainR), solver.method='lm')
	    moContR <- buildModelObj(model = as.formula(myContR), solver.method='lm')
	    
	    # fit QLearn
	    # generate the output code for fitting
	    output$myFitQ1 <- renderText({paste("fitQ1 <- qLearn(moMain = moMain, 
	                                        moCont = moCont, response =", 
	                                        input$varResponseR, ",",
	                                        "data = df, txName = ", input$varTrtR, ")")})
	    # fit QLearn
	    fitQ1 <- qLearn(moMain = moMainR, moCont = moContR,  
	                    response = as.matrix(df[names(df) == input$varResponseR]), 
	                    data = df, txName = input$varTrtR)
	    # put coeff from QLearn into data frame
	    coeffTbl <- as.data.frame(coef(fitQ1)$Combined)
	    names(coeffTbl) <- c("Coefficients")
	    
	    # output coef
	    output$coeffTbl = renderTable({
	      if (input$getmodelR == 0) return(NULL)
	      coeffTbl})
	    output$res <- renderText({head(residuals(fitQ1))})
	    output$plot1 <- renderPlot({plot(fitQ1, which=1)})
	    output$plot2 <- renderPlot({plot(fitQ1, which=2)})
	    output$plot3 <- renderPlot({plot(fitQ1, which=3)})
	    output$plot4 <- renderPlot({plot(fitQ1, which=5)})
	  })
	    ##--------------------------- AIPWE ---------------------------------------------#
	    #------------------
	    # Specify treatment 
	    #------------------
	    output$varTrtA <- renderUI({
	      if (is.null(data())) return(NULL)
	      df <-data()
	      
	      items=names(df)
	      names(items)=items
	      selectInput("varTrtA", "Treatment:",items)
	    })
	    
	    #-----------------
	    # Specify response
	    #-----------------
	    output$varResponseA <- renderUI({
	      if (is.null(data())) return(NULL)
	      df <-data()
	      
	      items=names(df)
	      names(items)=items
	      selectInput("varResponseA", "Response:",items)
	    })
	    
	    #-------------
	    # Build moProp
	    #-------------
	    output$varPropA <- renderUI({
	      if (is.null(data())) return(NULL)
	      df <-data()
	      
	      varName <- names(df)
	      varName <- varName[!(varName %in% c(input$varTrtA, input$varResponseA)) ]
	      checkboxGroupInput("varPropA", 
	                         "Choose variables to be included in the propensity model", 
	                         varName)
	    })
	    #-------------
	    # Build moMain
	    #-------------
	    output$varMainA <- renderUI({
	      if (is.null(data())) return(NULL)
	      df <-data()
	      
	      varName <- names(df)
	      varName <- varName[!(varName %in% c(input$varTrtA, input$varResponseA)) ]
	      checkboxGroupInput("varMainA", 
	                         "Choose variables to be included in the main effect model", 
	                         varName)
	    })
	    
	    #-------------
	    # Build moCont
	    #-------------
	    output$varContA <- renderUI({
	      if (is.null(data())) return(NULL)
	      df <-data()
	      
	      varName <- names(df)
	      varName <- varName[!(varName %in% c(input$varTrtA, input$varResponseA)) ]
	      checkboxGroupInput("varContA", 
	                         "Choose variables to be included in the contrast model", 
	                         varName)
	    })
	    
	    #----------------------------------------
	    # Specify the class of the decision rules
	    #----------------------------------------
	    output$varRuleA <- renderUI({
	      if (is.null(data())) return(NULL)
	      df <-data()
	      varName <- names(df)
	      varName <- varName[!(varName %in% c(input$varTrtA, input$varResponseA)) ]
	      checkboxGroupInput("varRuleA", 
	                         "Choose variables to specify the class of regimes. 
	                         For simplicity, we are restrict to linear decision rule with the form
	                         a + b x1 + c x2", 
	                         varName)
	    })
	    
	  observeEvent(input$getmodelA, {
	      if (is.null(data())) return(NULL)
	      df <-data()
	      
	      # check if all the inputs are ready  
	      if(is.null(input$varResponseA)) return(NULL)
	      if(is.null(input$varTrtA)) return(NULL)
	      
	      if (is.null(input$varMainA)) return(NULL)
	      if (is.null(input$varContA)) return(NULL)
	      
	      # fit model when user request 
	      if (input$getmodelA == 0) return(NULL)
	      
	      # build moProp
	      varPropVectorA <- as.vector(input$varPropA)
	      myPropA <- paste("~", paste(varPropVectorA, collapse=" + "))
	      output$myPropA <- renderText({paste("moMain <- buildModelObj(model =",  
	                                         myPropA, ",  solver.method = 'glm', 
	                                         solver.args = list( 'family' = 'binomial' ),  
	                                         predict.method = 'predict.glm', 
	                                         predict.args = list( 'type' = 'response')")})
	      moPropA <- buildModelObj(model = as.formula(myPropA), solver.method = 'glm', 
	                              solver.args = list( 'family' = 'binomial' ),  
	                              predict.method = 'predict.glm', 
	                              predict.args = list( 'type' = 'response'))
	      
	      # build moMain
	      varMainVectorA <- as.vector(input$varMainA)
	      myMainA <- paste("~", paste(varMainVectorA, collapse=" + "))
	      output$myMainA <- renderText({paste("moMain <- buildModelObj(model =",  
	                                         myMainA, ",  solver.method='lm')")})
	      moMainA <- buildModelObj(model = as.formula(myMainA), solver.method='lm')
	      
	      # build moCont
	      varContVectorA <- as.vector(input$varContA)
	      myContA <- paste("~", paste(varContVectorA, collapse=" + "))
	      output$myContA <- renderText({paste("moCont <- buildModelObj(model =",  
	                                         myContA, ",  solver.method='lm')")})
	      moContA <- buildModelObj(model = as.formula(myContA), solver.method='lm')
	      
	      # extract the response
	      yA <- as.numeric(unlist(df[names(df) == input$varResponseA]))
	      
	      # extract the treatment variable
	      tx.varsA <- input$varTrtA
	      output$myContA <- renderText({paste("moCont <- buildModelObj(model =",  
	                                          myContA, ",  solver.method='lm')")})
	      
	      # define the treatment rules by reordering the data table
	      # the first two column will be in the decision rule
	      varRuleVectorA <- as.vector(input$varRuleA)
	      columnIdx <- grep(varRuleVectorA[2], names(df))
	      df <- df[, c(columnIdx, (1:ncol(df))[-columnIdx])]
	      varRuleVectorA <- as.vector(input$varRuleA)
	      columnIdx <- grep(varRuleVectorA[1], names(df))
	      dfA <- df[, c(columnIdx, (1:ncol(df))[-columnIdx])]
	      
	      tx.rulesA <- function(a,b,c,data){
	        as.numeric(a + b*data[,1] + c*data[,2] > 0 )} 
	      
	      # define the starting point 
	      c1 <- c(-1,-1,-1)
	      c2 <- c( 1, 1, 1)
	      Domains <- cbind(c1, c2)
	      starts <- c(0, 0, 0)
	      pop.size <- 50
	      #  browser();
	      ft <- optimalSeq(moPropen = moPropA,
	                       moMain = moMainA,
	                       moCont = moContA,
	                       data = df,
	                       response =yA,
	                       txName = tx.varsA,
	                       regimes = tx.rulesA,
	                       pop.size = pop.size,
	                       starting.values = starts,
	                       Domains = Domains)
	      
	      # coeff into data frame
	      output$ftest <- renderText({ print(estimator(ft)) })
	      
	    
	    ##--------------------------- classification --------------------------------------#
	    #------------------
	    # Specify treatment
	    #------------------
	    output$varTrtC <- renderUI({
	      if (is.null(data())) return(NULL)
	      df <-data()
	      
	      items=names(df)
	      names(items)=items
	      selectInput("varTrtC", "Treatment:",items)
	    })
	    
	    #-----------------
	    # Specify response
	    #-----------------
	    output$varResponseC <- renderUI({
	      if (is.null(data())) return(NULL)
	      df <-data()
	      
	      items=names(df)
	      names(items)=items
	      selectInput("varResponseC", "Response:",items)
	    })
	    
	    #-------------
	    # Build moProp
	    #-------------
	    output$varPropC <- renderUI({
	      if (is.null(data())) return(NULL)
	      df <-data()
	      
	      varName <- names(df)
	      varName <- varName[!(varName %in% c(input$varTrtC, input$varResponseC)) ]
	      checkboxGroupInput("varPropC", 
	                         "Choose variables to be included in the propensity model", 
	                         varName)
	    })
	    #-------------
	    # Build moMain
	    #-------------
	    output$varMainC <- renderUI({
	      if (is.null(data())) return(NULL)
	      df <-data()
	      
	      varName <- names(df)
	      varName <- varName[!(varName %in% c(input$varTrtC, input$varResponseC)) ]
	      checkboxGroupInput("varMainC", 
	                         "Choose variables to be included in the main effect model", 
	                         varName)
	    })
	    
	    #-------------
	    # Build moCont
	    #-------------
	    output$varContC <- renderUI({
	      if (is.null(data())) return(NULL)
	      df <-data()
	      
	      varName <- names(df)
	      varName <- varName[!(varName %in% c(input$varTrtC, input$varResponseC)) ]
	      checkboxGroupInput("varContC", 
	                         "Choose variables to be included in the contrast model", 
	                         varName)
	    })
	    
	    #----------------------------------------
	    # Specify the class of the decision rules/classification model
	    #----------------------------------------
	    output$varClass <- renderUI({
	      if (is.null(data())) return(NULL)
	      df <-data()
	      varName <- names(df)
	      varName <- varName[!(varName %in% c(input$varTrtC, input$varResponseC)) ]
	      checkboxGroupInput("varClass", 
	                         "Choose variables to specify the class of regimes. 
	                         For simplicity, we are restrict to linear decision rule with the form
	                         a + b x1 + c x2", 
	                         varName)
	    })
	    
      observeEvent(input$getmodelC, {
	      
	      if (is.null(data())) return(NULL)
	      df <-data()
	      
	      # check if all the inputs are ready  
	      if(is.null(input$varResponseC)) return(NULL)
	      if(is.null(input$varTrtC)) return(NULL)
	      
	      if (is.null(input$varMainC)) return(NULL)
	      if (is.null(input$varContC)) return(NULL)
	     # browser()	      
	      # fit model when user request 
	      if (input$getmodelC == 0) return(NULL)

	      # build moProp
	      varPropVectorC <- as.vector(input$varPropC)
	      myPropC <- paste("~", paste(varPropVectorC, collapse=" + "))
	      output$myPropC <- renderText({paste("moMain <- buildModelObj(model =",  
	                                         myPropC, ",  solver.method = 'glm', 
	                                         solver.args = list( 'family' = 'binomial' ),  
	                                         predict.method = 'predict.glm', 
	                                         predict.args = list( 'type' = 'response')")})
	      moPropC <- buildModelObj(model = as.formula(myPropC), solver.method = 'glm', 
	                              solver.args = list( 'family' = 'binomial' ),  
	                              predict.method = 'predict.glm', 
	                              predict.args = list( 'type' = 'response'))
	      
	      # build moMain
	      varMainVectorC <- as.vector(input$varMainC)
	      myMainC <- paste("~", paste(varMainVectorC, collapse=" + "))
	      output$myMainC <- renderText({paste("moMain <- buildModelObj(model =",  
	                                         myMainC, ",  solver.method='lm')")})
	      moMainC <- buildModelObj(model = as.formula(myMainC), solver.method='lm')
	      
	      # build moCont
	      varContVectorC <- as.vector(input$varContC)
	      myContC <- paste("~", paste(varContVectorC, collapse=" + "))
	      output$myContC <- renderText({paste("moCont <- buildModelObj(model =",  
	                                         myContC, ",  solver.method='lm')")})
	      moContC <- buildModelObj(model = as.formula(myContC), solver.method='lm')
	      
	      # extract the response
	      yC <- as.numeric(unlist(df[names(df) == input$varResponseC]))
	      
	      # extract the treatment variable
	      tx.varsC <- input$varTrtC
	
	      #---------------------------------   
	      # Define the classification model 
	      #---------------------------------
	      varClassVector <- as.vector(input$varClass)
	      myClass <- paste("~", paste(varClassVector, collapse=" + "))
	      output$myClass <- renderText({paste("moClass <- buildModelObj(model =",  
	                                          myClass, ",  solver.method='lm')")})
	      
	      class <- buildModelObj(model = as.formula(myClass), 
	                             solver.method =  'rpart' , 
	                             solver.args = list(method = 'class'), 
	                             predict.args = list(type= 'class'))
	      
	      
	      # classification solve
	      estClassOpt <- optimalClass(moPropen = moPropC,
	                               moMain = moMainC,
	                               moCont = moContC,
	                               moClass = class,
	                               data = df,
	                               response = yC,
	                               txName = tx.varsC,
	                               iter=0)
	      
	      # coeff into data frame
	      output$optClass <- renderText({ print(estimator(estClassOpt)) })
	      
	      # output coef
	      #output$coeffTbl = renderTable({
	      #  if (input$getmodel == 0) return(NULL)
	      #  coeffTbl})
	      #output$res <- renderText({head(residuals(fitQ1))})
	      #output$plot1 <- renderPlot({plot(fitQ1, which=1)})
	      #output$plot2 <- renderPlot({plot(fitQ1, which=2)})
	      #output$plot3 <- renderPlot({plot(fitQ1, which=3)})
	      #output$plot4 <- renderPlot({plot(fitQ1, which=5)})
	      })  
	  })
})